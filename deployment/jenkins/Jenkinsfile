/**
 * Jenkins Pipeline for Spring Boot Application Deployment to Heroku
 *
 * This pipeline automates the build, test, and deployment process for a Spring Boot application.
 * It includes stages for checkout, building, testing, and deploying to Heroku.
 *
 * Prerequisites:
 * - Jenkins with Maven and Git installed
 * - Heroku CLI installed on Jenkins agent
 * - Heroku API key stored in Jenkins credentials
 */

pipeline {
    agent any

    tools {
        maven 'Maven 3.9'  // Ensure Maven is configured in Jenkins Global Tools..
    }

    parameters {
        string(
            name: 'RELEASE_TAG',
            defaultValue: '',
            description: 'Release tag to build and deploy (leave empty to use build number)'
        )
        choice(
            name: 'DEPLOY_ENV',
            choices: ['development', 'production'],
            description: 'Environment to deploy'
        )
        booleanParam(
            name: 'RUN_TESTS',
            defaultValue: true,
            description: 'Run unit and integration tests'
        )
        string(
            name: 'CUSTOM_DOMAIN',
            defaultValue: 'idp-week6.glanze.space',
            description: 'Custom domain for smoke test (leave empty to use Heroku URL)'
        )
    }

    environment {
        // Heroku Credentials
        HEROKU_API_KEY = credentials('HEROKU_API_KEY')
        HEROKU_APP_NAME_DEV = 'week6-practice1-dev'
        HEROKU_APP_NAME_PROD = 'week6-practice1-prod'

        // Database Credentials (External MySQL Database)
        DATABASE_URL = credentials('db-url')
        DATABASE_USERNAME = credentials('db-username')
        DATABASE_PASSWORD = credentials('db-password')
        DATABASE_DRIVER = credentials('db-driver')

        // Application Configuration
        APP_NAME = 'week6-practice1'
        IMAGE_TAG = "${params.RELEASE_TAG ? params.RELEASE_TAG : env.BUILD_NUMBER}"
        DEPLOY_APP_NAME = "${params.DEPLOY_ENV == 'production' ? HEROKU_APP_NAME_PROD : HEROKU_APP_NAME_DEV}"

        // Custom Domain Configuration (for smoke test)
        // If CUSTOM_DOMAIN parameter is provided, use it; otherwise fallback to Heroku URL
        CUSTOM_DOMAIN = "${params.CUSTOM_DOMAIN}"
    }

    stages {
        // ============================================================
        // STAGE 1: Checkout Source Code
        // ============================================================
        stage('Checkout') {
            steps {
                checkout scm

                script {
                    // Extract Git information
                    env.GIT_BRANCH = sh(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()

                    env.GIT_COMMIT = sh(
                        script: 'git rev-parse HEAD',
                        returnStdout: true
                    ).trim()

                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()

                    env.GIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=format:"%an"',
                        returnStdout: true
                    ).trim()

                    env.GIT_MESSAGE = sh(
                        script: 'git log -1 --pretty=format:"%s"',
                        returnStdout: true
                    ).trim()

                    echo "Branch: ${env.GIT_BRANCH}"
                    echo "Commit: ${env.GIT_COMMIT_SHORT}"
                    echo "Author: ${env.GIT_AUTHOR}"
                    echo "Message: ${env.GIT_MESSAGE}"

                    // Send notification to Discord (optional)
                    script {
                        try {
                            withCredentials([string(credentialsId: 'discord-notification', variable: 'DISCORD_WEBHOOK')]) {
                                discordSend(
                                    webhookURL: DISCORD_WEBHOOK,
                                    title: "üöÄ Build Started!",
                                    description: """**Branch:** `${env.GIT_BRANCH}`
**Build:** `#${env.BUILD_NUMBER}`
**Status:** `üîÑ In Progress`
**Commit:** `${env.GIT_COMMIT_SHORT}`
**Author:** `${env.GIT_AUTHOR}`
**Message:** `${env.GIT_MESSAGE}`

**üîó Links:**
‚Ä¢ [View Build](${env.BUILD_URL})
‚Ä¢ [Console Output](${env.BUILD_URL}console)""",
                                    link: env.BUILD_URL,
                                    result: 'STARTED'
                                )
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è Discord notification not configured. Skipping notification..."
                            echo "To enable Discord notifications, add 'discord-notification' credential in Jenkins."
                        }
                    }
                }
            }
        }

        // ============================================================
        // STAGE 2: Build Application
        // ============================================================
        stage('Build') {
            steps {
                script {
                    echo "Building Spring Boot Application with Maven..."

                    // Set Maven options for better performance
                    // Note: MaxPermSize removed in Java 9+, using MetaspaceSize instead
                    withEnv([
                        'MAVEN_OPTS=-Xmx3072m -XX:MaxMetaspaceSize=512m',
                        "SPRING_PROFILES_ACTIVE=${params.DEPLOY_ENV}"
                    ]) {
                        // Clean, package, and skip tests for build stage
                        sh 'mvn clean package -DskipTests'
                    }

                    // Verify jar file was created
                    sh '''
                        if [ -f target/Week6_Practice1-0.0.1-SNAPSHOT.jar ]; then
                            echo "‚úÖ Build successful - JAR file created"
                            ls -lh target/Week6_Practice1-0.0.1-SNAPSHOT.jar
                        else
                            echo "‚ùå Build failed - JAR file not found"
                            exit 1
                        fi
                    '''
                }
            }
        }

        // ============================================================
        // STAGE 3: Run Tests (Optional)
        // ============================================================
        stage('Test') {
            when {
                expression { params.RUN_TESTS == true }
            }
            steps {
                script {
                    echo "Running Unit and Integration Tests..."

                    sh 'mvn test'

                    // Publish test results
                    junit allowEmptyResults: true, testResults: 'target/surefire-reports/*.xml'

                    // Optional: Publish code coverage with JaCoCo
                    // jacoco execPattern: 'target/jacoco.exec', ...
                }
            }
            post {
                always {
                    // Archive test reports
                    junit allowEmptyResults: true, testResults: 'target/surefire-reports/*.xml'

                    // Publish HTML test report (optional)
                    // publishHTML(target: [
                    //     allowMissing: false,
                    //     alwaysLinkToLastBuild: true,
                    //     keepAll: true,
                    //     reportDir: 'target/site/surefire-report.html',
                    //     reportFiles: 'index.html',
                    //     reportName: 'Test Report'
                    // ])
                }
            }
        }

        // ============================================================
        // STAGE 4: Code Quality (Optional - Commented Out)
        // ============================================================
        // stage('Code Quality Analysis') {
        //     steps {
        //         script {
        //             withSonarQubeEnv('SonarQube-Server') {
        //                 sh """
        //                     mvn sonar:sonar \
        //                     -Dsonar.projectKey=${APP_NAME} \
        //                     -Dsonar.projectName="${APP_NAME}" \
        //                     -Dsonar.sources=src/main/java \
        //                     -Dsonar.tests=src/test/java \
        //                     -Dsonar.java.binaries=target/classes \
        //                     -Dsonar.junit.reportPaths=target/surefire-reports
        //                 """
        //             }
        //         }
        //     }
        // }

        // ============================================================
        // STAGE 5: Security Scan - Dependencies (Optional)
        // ============================================================
        stage('Security Scan - Dependencies') {
            steps {
                script {
                    echo "Running OWASP Dependency Check..."

                    // Run OWASP dependency check if available
                    // sh 'mvn org.owasp:dependency-check-maven:check'

                    // Alternatively, use Maven dependency:tree to check for vulnerabilities
                    sh 'mvn dependency:tree || true'

                    echo "‚ö†Ô∏è Note: Configure OWASP Dependency Check plugin in pom.xml for automated scanning"
                }
            }
        }

        // ============================================================
        // STAGE 5.5: Install Heroku CLI (FIXED PATH)
        // ============================================================
        stage('Install Heroku CLI') {
            steps {
                script {
                    echo "Installing Heroku CLI directly to workspace..."

                    sh '''
                        # 1. Pastikan kita di root workspace
                        cd ${WORKSPACE}

                        # 2. Hapus instalasi lama jika ada (biar bersih)
                        rm -rf heroku heroku.tar.gz

                        # 3. Detect architecture
                        ARCH=$(uname -m)
                        if [ "$ARCH" = "x86_64" ]; then
                            DOWNLOAD_URL="https://cli-assets.heroku.com/heroku-linux-x64.tar.gz"
                        elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
                            DOWNLOAD_URL="https://cli-assets.heroku.com/heroku-linux-arm64.tar.gz"
                        else
                            echo "‚ùå Unsupported architecture: $ARCH"
                            exit 1
                        fi

                        # 4. Download langsung (Tanpa masuk folder tmp)
                        echo "Downloading Heroku CLI from: $DOWNLOAD_URL"
                        curl -fsSL "$DOWNLOAD_URL" -o heroku.tar.gz

                        # 5. Extract (Otomatis akan membuat folder bernama 'heroku')
                        echo "Extracting..."
                        tar -xzf heroku.tar.gz

                        # 6. Hapus file mentahan tar.gz
                        rm heroku.tar.gz

                        # 7. Verifikasi path
                        echo "Checking directory structure..."
                        ls -F ${WORKSPACE}/heroku/bin/
                    '''

                    // 8. Update PATH agar stage selanjutnya bisa panggil 'heroku'
                    // Ini bagian paling PENTING: Menambahkan folder bin ke System Path Jenkins
                    env.PATH = "${env.WORKSPACE}/heroku/bin:${env.PATH}"

                    // 9. Test Command
                    sh 'heroku --version'
                    echo "‚úÖ Heroku CLI installed successfully!"
                }
            }
        }

        // ============================================================
        // STAGE 6: Deploy to Heroku
        // ============================================================
        stage('Deploy to Heroku') {
            steps {
                script {
                    echo "Deploying to Heroku App: ${DEPLOY_APP_NAME} (${params.DEPLOY_ENV})"

                    // Verify Heroku CLI is accessible
                    sh '''
                        echo "Verifying Heroku CLI installation..."
                        heroku --version
                        echo "‚úÖ Heroku CLI ready"
                    '''

                    // Authenticate with Heroku using API key
                    withEnv(["HEROKU_API_KEY=${HEROKU_API_KEY}"]) {
                        sh '''
                            # Authenticate using API token (more reliable than export)
                            echo "${HEROKU_API_KEY}" | heroku auth:token

                            # Verify authentication
                            heroku auth:whoami
                            echo "‚úÖ Successfully authenticated to Heroku"
                        '''
                    }

                    // Create Heroku app if it doesn't exist (first time only)
                    sh '''
                        # Check if app exists, create if not
                        if ! heroku apps:info --app "${DEPLOY_APP_NAME}" 2>/dev/null; then
                            echo "Creating new Heroku app: ${DEPLOY_APP_NAME}"
                            heroku create "${DEPLOY_APP_NAME}"
                        else
                            echo "‚úÖ Heroku app exists: ${DEPLOY_APP_NAME}"
                        fi
                    '''

                    // Set Java version and environment variables
                    withEnv(["DEPLOY_ENV=${params.DEPLOY_ENV}"]) {
                        sh '''
                            echo "Setting Java and environment variables..."
                            heroku config:set JAVA_OPTS="-Xmx512m -Xms256m" --app "${DEPLOY_APP_NAME}"
                            heroku config:set SPRING_PROFILES_ACTIVE="${DEPLOY_ENV}" --app "${DEPLOY_APP_NAME}"
                            echo "‚úÖ Environment variables set"
                        '''
                    }

                    // Set Database Configuration (FIXED: Menggunakan Standar Spring Boot)
                    withEnv([
                        "HEROKU_API_KEY=${HEROKU_API_KEY}",
                        "DATABASE_URL=${DATABASE_URL}",       // Mengambil dari Credential 'db-url'
                        "DATABASE_USERNAME=${DATABASE_USERNAME}", // Mengambil dari Credential 'db-username'
                        "DATABASE_PASSWORD=${DATABASE_PASSWORD}", // Mengambil dari Credential 'db-password'
                        "DATABASE_DRIVER=${DATABASE_DRIVER}"      // Mengambil dari Credential 'db-driver'
                    ]) {
                        sh '''
                            # Export HEROKU_API_KEY agar CLI bisa login
                            export HEROKU_API_KEY

                            echo "Configuring database connection..."

                            # KITA UBAH NAMA VARIABELNYA KE STANDAR SPRING BOOT
                            # Agar aplikasi otomatis baca tanpa perlu ubah application.properties

                            heroku config:set SPRING_DATASOURCE_URL="${DATABASE_URL}" --app "${DEPLOY_APP_NAME}"
                            heroku config:set SPRING_DATASOURCE_USERNAME="${DATABASE_USERNAME}" --app "${DEPLOY_APP_NAME}"
                            heroku config:set SPRING_DATASOURCE_PASSWORD="${DATABASE_PASSWORD}" --app "${DEPLOY_APP_NAME}"
                            heroku config:set SPRING_DATASOURCE_DRIVER_CLASS_NAME="${DATABASE_DRIVER}" --app "${DEPLOY_APP_NAME}"

                            echo "‚úÖ Database configuration set (Spring Boot Standard)"
                        '''
                    }

                    // Set buildpacks (FIXED: Ignore error if already set)
                    sh '''
                        echo "Setting Heroku buildpacks..."

                        # Jalankan set buildpack.
                        # Tambahan '|| true' artinya: "Kalau gagal (karena udah ada), biarin aja, lanjut terus!"
                        heroku buildpacks:set https://github.com/heroku/heroku-buildpack-java --app "${DEPLOY_APP_NAME}" || echo "‚ö†Ô∏è Buildpack setup skipped (likely already set)"

                        echo "‚úÖ Buildpack configured"
                    '''

                    // Deploy using Git (FIXED: Explicit Refspec)
                    withEnv(["HEROKU_API_KEY=${HEROKU_API_KEY}", "DEPLOY_APP_NAME=${DEPLOY_APP_NAME}"]) {
                        sh '''
                            echo "Deploying to Heroku..."

                            # 1. Setup Remote
                            # Hapus dulu biar bersih (mencegah error 'already exists')
                            git remote remove heroku-deploy || true

                            # Tambah remote baru
                            git remote add heroku-deploy https://heroku:${HEROKU_API_KEY}@git.heroku.com/${DEPLOY_APP_NAME}.git

                            # 2. Push (BAGIAN PENTING)
                            # Gunakan 'HEAD:refs/heads/main'
                            # Artinya: "Ambil commit saya saat ini (HEAD), paksakan masuk ke branch main (refs/heads/main) di sana"
                            git push heroku-deploy HEAD:refs/heads/main --force

                            # 3. Cleanup
                            git remote remove heroku-deploy
                            echo "‚úÖ Deployment completed"
                        '''
                    }

                    echo "‚úÖ Deployment successful!"
                }
            }
        }

        // ============================================================
        // STAGE 7: Health Check / Smoke Test
        // ============================================================
        stage('Smoke Test') {
            steps {
                script {
                    echo "Running smoke tests against deployed application..."

                    // Determine application URL
                    // Use custom domain if provided, otherwise fallback to Heroku URL
                    def appUrl = ''

                    if ("${CUSTOM_DOMAIN}"?.trim()) {
                        // Custom domain is provided, use it
                        appUrl = "https://${CUSTOM_DOMAIN}"
                        echo "Using custom domain: ${appUrl}"
                    } else {
                        // No custom domain, get Heroku URL
                        appUrl = sh(
                            script: """
                                heroku apps:info --app ${DEPLOY_APP_NAME} --json | grep -o '"web_url":"[^"]*"' | cut -d'"' -f4
                            """,
                            returnStdout: true
                        ).trim()
                        echo "Using Heroku URL: ${appUrl}"
                    }

                    env.APP_URL = appUrl

                    // Wait for application to start
                    echo "Waiting for application to be ready (60 seconds)..."
                    sleep time: 60, unit: 'SECONDS'

                    // Health check using Actuator endpoint
                    // Pass appUrl as environment variable to shell script
                    withEnv(["APP_URL=${appUrl}"]) {
                        sh """
                            set +e
                            MAX_RETRIES=10
                            RETRY_COUNT=0

                            while [ \${RETRY_COUNT} -lt \${MAX_RETRIES} ]; do
                                echo "Attempt \$((RETRY_COUNT + 1)) of \${MAX_RETRIES}"

                                # Check health endpoint
                                HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" \${APP_URL}/actuator/health || echo "000")

                                if [ "\${HTTP_CODE}" = "200" ]; then
                                    echo "‚úÖ Health check passed!"
                                    echo "Response:"
                                    curl -s \${APP_URL}/actuator/health | jq . || echo "Health check response"
                                    exit 0
                                fi

                                echo "‚è≥ Waiting for service... (HTTP: \${HTTP_CODE})"
                                sleep 10
                                RETRY_COUNT=\$((RETRY_COUNT + 1))
                            done

                            echo "‚ùå Health check failed after \${MAX_RETRIES} attempts"
                            echo "URL attempted: \${APP_URL}"
                            echo ""
                            echo "üîç Troubleshooting:"
                            echo "1. Check Heroku app logs: heroku logs --tail --app ${DEPLOY_APP_NAME}"
                            echo "2. Check if dyno is running: heroku ps --app ${DEPLOY_APP_NAME}"
                            echo "3. Check if app started: heroku ps:restart --app ${DEPLOY_APP_NAME}"
                            exit 1
                        """
                    }
                }
            }
        }

        // ============================================================
        // STAGE 8: Database Migration (Optional - DISABLED)
        // ============================================================
        // NOTE: Database migration disabled - using external MySQL database
        // The application will auto-create/update tables using JPA/Hibernate
        // If you need manual migrations, enable Flyway and uncomment below
        /*
        stage('Database Migration') {
            when {
                expression { params.DEPLOY_ENV == 'production' }
            }
            steps {
                script {
                    echo "Running database migrations..."

                    // Run Flyway migrations if configured
                    // sh "mvn flyway:migrate -Dflyway.url=\$DATABASE_URL"

                    echo "‚úÖ Database migration completed"
                }
            }
        }
        */
    }

    // ============================================================
    // POST ACTIONS
    // ============================================================
    post {
        success {
            script {
                echo "‚úÖ Pipeline completed successfully!"

                // Send success notification to Discord
                try {
                    withCredentials([string(credentialsId: 'discord-notification', variable: 'DISCORD_WEBHOOK')]) {
                        discordSend(
                            webhookURL: DISCORD_WEBHOOK,
                            title: "‚úÖ Deploy Success!",
                            description: """**Branch:** `${env.GIT_BRANCH}`
**Build:** `#${env.BUILD_NUMBER}`
**Status:** `‚úÖ Success`
**Environment:** `${params.DEPLOY_ENV}`
**Heroku App:** `${DEPLOY_APP_NAME}`

**üìù Changes:**
`${env.GIT_COMMIT_SHORT}` ${env.GIT_MESSAGE} - ${env.GIT_AUTHOR}

**üîó Links:**
‚Ä¢ [View Build](${env.BUILD_URL})
‚Ä¢ [Console Output](${env.BUILD_URL}console)
‚Ä¢ [üåê Application](${env.APP_URL})
‚Ä¢ [Actuator Health](${env.APP_URL}/actuator/health)
‚Ä¢ [Swagger UI](${env.APP_URL}/swagger-ui/index.html)

**‚è±Ô∏è Duration:** `${currentBuild.durationString}`""",
                            link: env.BUILD_URL,
                            result: 'SUCCESS'
                        )
                    }
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Discord notification not configured. Skipping notification..."
                }
            }
        }

        failure {
            script {
                echo "‚ùå Pipeline failed!"

                // Get failure information
                def failureMessage = "Unknown error"
                try {
                    def log = currentBuild.rawBuild.getLog(100)
                    failureMessage = log.findAll { it.contains('ERROR') || it.contains('FAILED') }
                                          .take(5)
                                          .join('\n')
                    if (!failureMessage) {
                        failureMessage = "Check console output for details"
                    }
                } catch (Exception e) {
                    failureMessage = "Check console output for details"
                }

                // Send failure notification to Discord
                try {
                    withCredentials([string(credentialsId: 'discord-notification', variable: 'DISCORD_WEBHOOK')]) {
                        discordSend(
                            webhookURL: DISCORD_WEBHOOK,
                            title: "‚ùå Build Failed!",
                            description: """**Branch:** `${env.GIT_BRANCH}`
**Build:** `#${env.BUILD_NUMBER}`
**Status:** `‚ùå Failed`
**Environment:** `${params.DEPLOY_ENV}`
**Heroku App:** `${DEPLOY_APP_NAME}`

**üìù Last Commit:**
`${env.GIT_COMMIT_SHORT}` ${env.GIT_MESSAGE} - ${env.GIT_AUTHOR}

**üí• Failure Info:**
```
${failureMessage}
```

**üîó Links:**
‚Ä¢ [View Build](${env.BUILD_URL})
‚Ä¢ [Console Output](${env.BUILD_URL}console)

**‚è±Ô∏è Duration:** `${currentBuild.durationString}`""",
                            link: env.BUILD_URL,
                            result: 'FAILURE'
                        )
                    }
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Discord notification not configured. Skipping notification..."
                }
            }
        }

        always {
            echo "Pipeline execution completed"
            // Clean up workspace if needed
            // cleanWs().
        }
    }
}
